Base Tokenizer
----------

* Create new tokenizers while changing kwargs and functions
    - Make an entirely fake tokenizer for fake language
    - Insert new values with `tokens`
        a. some can be completely new
        b. some will override previous ones with new token regexs
        c. some will override previous ones with None to not use those tokens at all
    - Insert new token handling functions with `token_handlers`
    - Turn `insert_special_tokens` on and off
    - Turn `case_sensitive` on and off
* override special functions, token handler functions, default values with class
* passing different call args/kwargs
    - match_instruction_address
    - newline_tup (changed and None)
    - special kwargs passed to overridden functions
    - passing values as single/multiple strings
* Default tokens
    - immediate values
    - string literals (and fails)
    - disassembler infos (and fails)
        * just parsing for now on tokenizers
    - split immediate (and fails)
        * and merging behavior
    - spacing/newlines
    - symbols (+*[]:)
    - instruction address
        * with and without colon ':', with and without spacing around colon, multiple colons
        * Plain colon at beginning, colon after other tokens
        * No negatives as instruction address
* Empty string
* __dunder__ functions can be called (including __call__)
    - Args passed to __call__ get transferred to .tokenize
    - __eq__ is different with different tokens/classes
    - __hash__'s are different
* Pickling/unpickling
    - Objects are still equal
    - parameter saver works even with lambdas in __init__


BaseNormalizer
--------------

* Initialized, and with different kwargs
    - tokenizer
    - overridden token_handlers
    - token_sep
    - tokenization_level
    - Different class args
        * DEFAULT_TOKENIZATION_LEVEL
* All tokens are handled and normalized
    - Replace the handlers for all tokens to return "<token_type>"
    - All of the matched tokens
    - mismatched/unknown tokens
* Register different opcode handlers
* Passing kwargs through to tokenizer
* Pickling/unpickling
    - Objects are still equal
    - parameter saver works even with lambdas in __init__
* Split immediates
* Empty string
* Immediates are all converted to decimal
* __dunder__ functions can be called (including __call__)
    - Args passed to __call__ get transferred to .tokenize
* Disassembler info
* Equality to other normalizers with different __init__ kwargs
* Annonymize tokens


CFGEdge
-------

* Can only construct with two basic blocks and a valid edge_type
* Can make edge_type either with enum or string name
* Are immutable
    - At least, as much as possible
    - No setting attributes or calling __init__ again
* Builting __dunder__ methods can be called and return expected types
* equal and hashing works
* properties work as expected
    - is_normal_edge, is_function_call_edge
    - is_branch


CFGBasicBlock
-------------

* can be constructed correctly
    - values being none/Empty
    - values of different iterable types
    - Everything is expected type afterwards (only parent_function can be none)
    - Edges are converted to sets afterwards, no duplicates
    - The .address is -1 if None, converted correctly if not, and set to asm_memory_addresses[0] if that exists and .address is None
* properties work as expected
    - num_* count things right
    - asm_counts returns mapping of counted asm lines
    - is_function_entry, is_function_jump, is_function_call, is_multi_function_call
    - all_edges
* remove_edge removes lo and behold, the edge from that block
* get_sorted_edges with all kwargs
* has_edge() and calls()
* equal and hashing works
* don't worry about pickling and getting/setting states right now, that will be handled by CFG-level pickling


CFGFunction
-----------

* can be constructed correctly
    - Values being none/Empty
    - Values of different iterable types
    - Everything is expected type afterwards
* properties function correctly
    - num_blocks, is_extern_function, is_intern_function
    - num_asm_lines, asm_counts
    - is_recursive, is_root_function
    - called_by, num_fc_edges
    - function_entry_block


CFG
---

* construction
    - Values being none/empty
* Building CFG from code
* functions_dict, blocks_dict
* add_function(override=False)
* properties
    - functions, blocks, edges
    - num_edges, num_blocks, num_functions, num_asm_lines
    - asm_counts
* get_function, get_function_by_name, get_block, get_block_containing_address
* set_tokens, update_metadata